

# üìÑ LeetCode 68 - Text Justification


#### üåê English Version - UMPIRE Method


### üîç U ‚Äî Understand the Problem

You are given a list of words and a maxWidth value. Format the text such that:

* Each line contains as many words as possible
* Each line is exactly `maxWidth` characters long
* Lines (except the last one) must be **fully justified**:

  * Words are separated by evenly distributed spaces
  * Extra spaces are added to the **leftmost** gaps if not divisible
* The last line is **left-justified**, and no extra space is inserted between words

---

### üß™ M ‚Äî Match Examples

#### Example 1

```txt
Input:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16

Output:
[
  "This    is    an",
  "example  of text",
  "justification.  "
]
```

#### Example 2

```txt
Input:
words = ["What","must","be","acknowledgment","shall","be"]
maxWidth = 16

Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
```

---

### üõ†Ô∏è P ‚Äî Plan

1. Use a list `line` to collect words for the current line
2. Once adding a word would overflow `maxWidth`, format the current line:

   * If only one word, left-justify and pad with spaces
   * If multiple words, distribute spaces:

     * Compute evenly divided spaces
     * Add extra spaces to the left
3. Repeat for all lines
4. Handle the **last line** separately (left-justified)

---

### üíª I ‚Äî Implement

#### üêç Python

```python
from typing import List

class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res = []              # Stores the final justified lines
        line = []             # Current line words
        num_of_letters = 0    # Total characters in the line (excluding spaces)

        for word in words:
            # Check if adding this word would exceed maxWidth
            if num_of_letters + len(word) + len(line) > maxWidth:
                spaces = maxWidth - num_of_letters

                if len(line) == 1:
                    # Only one word ‚Üí pad spaces at end
                    res.append(line[0] + ' ' * spaces)
                else:
                    # Distribute spaces evenly
                    space_between = spaces // (len(line) - 1)
                    extra = spaces % (len(line) - 1)

                    # Add extra space to leftmost gaps
                    for i in range(extra):
                        line[i] += ' '

                    # Join words with calculated spaces
                    res.append((' ' * space_between).join(line))

                # Reset for next line
                line = []
                num_of_letters = 0

            line.append(word)
            num_of_letters += len(word)

        # Handle the last line (left-justified)
        last_line = ' '.join(line)
        res.append(last_line + ' ' * (maxWidth - len(last_line)))

        return res
```

---

#### üåê JavaScript

```javascript
var fullJustify = function(words, maxWidth) {
    const res = [];
    let line = [], lineLength = 0;

    for (let word of words) {
        if (lineLength + word.length + line.length > maxWidth) {
            const spaces = maxWidth - lineLength;

            if (line.length === 1) {
                res.push(line[0] + ' '.repeat(spaces));
            } else {
                const spaceBetween = Math.floor(spaces / (line.length - 1));
                let extra = spaces % (line.length - 1);

                for (let i = 0; i < extra; i++) {
                    line[i] += ' ';
                }

                res.push(line.join(' '.repeat(spaceBetween)));
            }

            line = [];
            lineLength = 0;
        }

        line.push(word);
        lineLength += word.length;
    }

    const lastLine = line.join(' ');
    res.push(lastLine + ' '.repeat(maxWidth - lastLine.length));

    return res;
};
```

---

### üîé R ‚Äî Review

Test on:

* A single long word
* Words that exactly fill maxWidth
* One word per line
* Spaces that don‚Äôt divide evenly
* Final line with multiple words

---

### üìä E ‚Äî Evaluate

| Type             | Complexity                       |
| ---------------- | -------------------------------- |
| Time Complexity  | O(n), where n = total characters |
| Space Complexity | O(n) for output list             |

---

### üß† Solution Build-upÔΩúËß£Ê≥ïÂª∫ÊßãÊÄùË∑Ø

1. Start by collecting words in a `line` buffer until the next word would overflow
2. Once full, calculate how many spaces to insert:

   * Evenly divide space
   * Extra spaces go to the leftmost gaps
3. Use `.join()` to format
4. Reset buffer and move to next line
5. At the end, format the last line with left justification

#
#
#

#### üìò ‰∏≠ÊñáÁâà - UMPIRE ÊñπÊ≥ï

### üîç U ‚Äî ÁêÜËß£ÂïèÈ°å

* Áµ¶‰Ω†‰∏ÄÂÄãÂñÆÂ≠óÂàóË°® `words` Âíå‰∏ÄÂÄãÊï¥Êï∏ `maxWidth`
* ÊØèË°åÈúÄË¶ÅÂâõÂ•ΩÂ∞çÈΩäÂà∞ `maxWidth` ÂØ¨Â∫¶
* ÂñÆÂ≠ó‰πãÈñìÁöÑÁ©∫Ê†ºÂøÖÈ†àÂπ≥ÂùáÂàÜÈÖçÔºàÂ∑¶Âè≥Â∞çÈΩäÔºâ
* Ëã•‰∏çËÉΩÂπ≥Âùá ‚Üí Â∑¶ÈÇäÂÑ™ÂÖàÂ§öÂä†‰∏ÄÊ†ºÁ©∫Ê†º
* **ÊúÄÂæå‰∏ÄË°å** Ë¶ÅÂ∑¶Â∞çÈΩä

---

### üß™ M ‚Äî ÁØÑ‰æãÂåπÈÖç

#### ÁØÑ‰æã

```txt
Input:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16

Output:
[
  "This    is    an",
  "example  of text",
  "justification.  "
]
```

---

### üõ†Ô∏è P ‚Äî Ëß£È°åË®àÁï´

1. ‰ΩøÁî® `line` Êî∂ÈõÜÂñÆÂ≠óÔºåÂè™Ë¶Å‰∏çË∂ÖÂá∫Ë°åÂØ¨Â∞±ÁπºÁ∫åÂä†
2. ‰∏ÄÊó¶Ë∂ÖÂá∫ÔºåÂ∞±ÈÄ≤Ë°åÂ∞çÈΩäÔºö

   * Âè™Êúâ‰∏ÄÂÄãÂñÆÂ≠ó ‚Üí Áõ¥Êé•Âè≥Ë£úÁ©∫Ê†º
   * Â§öÂÄãÂñÆÂ≠ó ‚Üí Âπ≥ÂùáÂàÜÈÖçÁ©∫Ê†ºÔºåÂ∑¶ÂÅ¥ÂÑ™ÂÖàË£ú
3. ÈáçË§áÁõ¥Âà∞ÊâÄÊúâÂñÆÂ≠óËôïÁêÜÂÆå
4. ÊúÄÂæå‰∏ÄË°åË¶ÅÂñÆÁç®ËôïÁêÜ ‚Üí Â∑¶Â∞çÈΩä

---

### üíª I ‚Äî ÂØ¶‰ΩúÔºàË´ãÂèÉËÄÉËã±ÊñáÊÆµËêΩÔºâ

---

### üîé R ‚Äî Ê™¢Êü•ËàáÊ∏¨Ë©¶

* Â§öÂÄãÂñÆÂ≠óÂâõÂ•ΩÂ°ûÊªø
* Á©∫Ê†ºÁÑ°Ê≥ïÂπ≥ÂùáÂàÜÈÖç
* Âè™Êúâ‰∏ÄÂÄãÂñÆÂ≠óÁöÑË°å
* ÊúÄÂæå‰∏ÄË°åÂè™Êúâ‰∏ÄÂÄãÊàñÂ§öÂÄãÂñÆÂ≠ó
* Á©∫Â≠ó‰∏≤ËôïÁêÜ

---

### üìä E ‚Äî ÊïàËÉΩÂàÜÊûê

| È°ûÂà•    | Ë§áÈõúÂ∫¶  |
| ----- | ---- |
| ÊôÇÈñìË§áÈõúÂ∫¶ | O(n) |
| Á©∫ÈñìË§áÈõúÂ∫¶ | O(n) |

---

### üß† Ëß£Ê≥ïÂª∫ÊßãÈÇèËºØ

1. ÂÖàÊÄùËÄÉÂ¶Ç‰ΩïÂ∞áÂñÆÂ≠ó‰æùÂ∫èÊîæÈÄ≤‰∏ÄË°åÔºå‰∏çË∂ÖÂá∫Ë°åÂØ¨
2. ‰∏ÄÊó¶Â°û‰∏ç‰∏ãÔºåËôïÁêÜÁõÆÂâçË°åÁöÑÊéíÁâàÔºàÁ©∫Ê†ºÂπ≥ÂùáË£ú„ÄÅÂ∑¶ÂÅ¥Â§öË£úÔºâ
3. ÁâπÊÆäÊÉÖÊ≥ÅÔºöËã•Âè™Êúâ‰∏ÄÂÄãÂñÆÂ≠ó ‚Üí Èù†Â∑¶Ë£úÁ©∫Ê†º
4. ÊúÄÂæå‰∏ÄË°å‰∏çÂÅöÂ∞çÈΩä ‚Üí Âè™Â∑¶Â∞çÈΩäÂÜçË£úÁ©∫Ê†ºËá≥ `maxWidth`
5. ÈÅéÁ®ã‰∏≠Á∂≠ÊåÅ `line` Ëàá `num_of_letters` ÁãÄÊÖãÂç≥ÂèØÂÆåÊàêÊï¥È´îÊéíÁâàÈÇèËºØ

#
#
#

# üí° Solution Build-upÔΩúËß£Ê≥ïÂª∫ÊßãÊÄùË∑Ø


#### üß± Step 1: ÂæûÂïèÈ°å‰∏≠ÊèêÁÖâÂá∫Ê†∏ÂøÉ‰ªªÂãô

* Â∞á‰∏ÄÈÄ£‰∏≤ÂñÆÂ≠ó `words` ÂàÜÊàê„ÄåÂâõÂ•Ω‰∏çË∂ÖÈÅé `maxWidth`„ÄçÁöÑ‰∏ÄË°åË°å
* ÊØèË°åÈúÄÂÅöÂà∞Â∑¶Âè≥Â∞çÈΩä
* ÊúÄÂæå‰∏ÄË°åÂâáÂ∑¶Â∞çÈΩäÂç≥ÂèØ

---

#### üß† Step 2: ÂÖàËôïÁêÜ„ÄåÂàÜË°å„ÄçÁöÑÈÇèËºØ

> Â∞áÂñÆÂ≠ó‰æùÂ∫èÂä†ÂÖ• `line` Êö´Â≠òË°å‰∏≠Ôºå‰∏¶Á¥ØÂä†Â≠óÊØçÊï∏Ôºà‰∏çÂê´Á©∫Ê†ºÔºâ
> ÊØèÊ¨°Âà§Êñ∑ÊòØÂê¶Âä†ÂÖ• `word` ÂæåÔºåË°åÂÖßÂ≠óÊØçÊï∏ + ÊúÄÂ∞ëÁ©∫Ê†ºÊï∏ `len(line)` ÊòØÂê¶Ë∂ÖÂá∫ `maxWidth`

```python
if num_of_letters + len(word) + len(line) > maxWidth:
```

ÈÄô‰∏ÄË°å‰ª£Ë°®„ÄåÂ¶ÇÊûúÂÜçÂä†ÂÖ• `word`ÔºåË°åÂØ¨Â∞±Ë∂ÖÂá∫ÔºåÂ∞±ÂÖàÊääÈÄôË°åËôïÁêÜÊéâ„Äç

---

#### üé® Step 3: ËôïÁêÜÈÄô‰∏ÄË°åÁöÑÊéíÁâàÔºàJustifyÔºâ

* Ëã•ÈÄô‰∏ÄË°åÂè™Êúâ‰∏ÄÂÄãÂñÆÂ≠ó ‚Üí Áõ¥Êé•Èù†Â∑¶Ë£úÁ©∫Ê†º
* Ëã•ÊúâÂ§öÂÄãÂñÆÂ≠ó ‚Üí Ë®àÁÆóË©≤Ë°åÈÇÑÂâ©Â§öÂ∞ëÁ©∫Ê†ºÁ©∫Èñì

  ```python
  spaces = maxWidth - num_of_letters
  ```
* Êé•ËëóÔºö

  * ÊØèÂÄãÈñìÈöîÂàÜÈÖçÂü∫Êú¨Á©∫Ê†ºÊï∏
  * Â§öÈ§òÁ©∫Ê†ºÂàÜÁµ¶Â∑¶ÈÇä
  * ÂÜçÁî® `.join()` Âêà‰ΩµÊØèÂÄãÂñÆÂ≠óÂíåÁ©∫Ê†º

ÈÄô‰∏ÄÊ≠•ÊòØÈÄôÈ°åÈÇèËºØÁöÑÁ≤æÈ´ì‰πã‰∏Ä

---

#### üîÅ Step 4: ËôïÁêÜÂÆå‰∏ÄË°åÂæåÔºåË®òÂæóÈáçÁΩÆÊö´Â≠òËÆäÊï∏

> Êää `line` Âíå `num_of_letters` Ê∏ÖÁ©∫ÔºåÊ∫ñÂÇôÈñãÂßã‰∏ã‰∏ÄË°åÁöÑÊî∂ÈõÜ

```python
line = []
num_of_letters = 0
```

---

#### üèÅ Step 5: ËôïÁêÜÊúÄÂæå‰∏ÄË°åÔºàleft-justifiedÔºâ

Âõ†ÁÇ∫ÊúÄÂæå‰∏ÄË°å‰∏çÊúÉËß∏ÁôºË∂ÖÂá∫ `maxWidth` ÁöÑÊ¢ù‰ª∂ÔºåÊâÄ‰ª•Ë¶ÅÂú®ÊúÄÂæåÂè¶Â§ñË£úËôïÁêÜ

```python
last_line = ' '.join(line)
res.append(last_line + ' ' * (maxWidth - len(last_line)))
```

* ÂñÆÂ≠ó‰πãÈñìÂè™Ë£ú‰∏ÄÂÄãÁ©∫Ê†º
* Ââ©‰∏ãÁöÑÁ©∫Ê†ºÁµ±‰∏ÄË£úÂú®Âè≥ÂÅ¥

---

#### üìå ÈÇèËºØÊµÅÁ®ãÂúñÊëòË¶ÅÔºö

```text
1. ÂàùÂßãÂåñ res, line, num_of_letters

2. Â∞çÊØèÂÄãÂñÆÂ≠óÔºö
    - Â¶ÇÊûúÂä†ÂÖ• word ÂæåÊúÉË∂ÖÂá∫ maxWidthÔºö
        ‚Üí ÂÖàËôïÁêÜÁõÆÂâçÈÄô‰∏ÄË°åÔºö
            - Ëã•Âè™Êúâ‰∏ÄÂÄãÂ≠ó ‚Üí Ë£úÁ©∫Ê†ºÂú®Âè≥ÈÇä
            - Ëã•Â§öÂÄãÂ≠ó ‚Üí Ë®àÁÆóÂü∫Êú¨Á©∫Ê†º„ÄÅÂπ≥ÂùáË£úÔºåÂ∑¶ÂÅ¥Â§öË£ú
        ‚Üí Â∞áÊ†ºÂºèÂåñÂ•ΩÁöÑË°åÂä†Âà∞ÁµêÊûú
        ‚Üí Ê∏ÖÁ©∫ line ËàáÂ≠óÊØçÁ∏ΩÊï∏
    - ÁÑ∂ÂæåÂ∞á word Âä†ÂÖ•Êñ∞Ë°å

3. ËôïÁêÜÊúÄÂæå‰∏ÄË°åÔºöÂ∑¶Â∞çÈΩäÔºåÂ∞æÈÉ®Ë£úÁ©∫Ê†º

4. ÂõûÂÇ≥ res
```

#
#
#


# üé§ Full Spoken-Style Interview Answer

**LeetCode 68 ‚Äì Text Justification**


### 1Ô∏è‚É£ Clarify the Problem

üó£Ô∏è

> Sure! So, we‚Äôre given an array of strings called `words` and an integer `maxWidth`, which represents the maximum number of characters allowed in each line of text.
>
> Our task is to format the text so that each line:
>
> * is exactly `maxWidth` characters long
> * is fully justified, meaning both left and right edges are aligned
>
> We need to:
>
> * put as many words as possible in each line
> * distribute spaces evenly between words
> * and if the number of spaces doesn‚Äôt divide evenly, extra spaces go to the **left** first
>
> The **last line** must be left-justified ‚Äî that is, words separated by a single space, and any remaining space padded on the right.

> The output should be a list of strings, where each string represents one justified line.

---

### 2Ô∏è‚É£ Discuss Edge Cases

üó£Ô∏è
Here are a few edge cases that I would want to consider:

* If a line contains only **one word**, we must left-align it and pad spaces at the end to reach `maxWidth`
* The **last line** should never be fully justified ‚Äî it should be **left-justified only**
* If a word itself is longer than `maxWidth`, we might need to assume that all words are valid (as the problem guarantees)
* Input might be exactly divisible, or require uneven spacing, so we need to handle rounding space gaps carefully

---

### 3Ô∏è‚É£ Consider Brute-force and Optimal Approach

üó£Ô∏è

> My approach will be **greedy**, line-by-line.
> I will scan the list of words and keep adding them to a temporary `line` buffer **until the next word would make the line exceed `maxWidth`**.

> Once I‚Äôve reached that point, I will:
>
> * calculate the number of remaining spaces I can distribute
> * determine how to spread those spaces across the current words

> I‚Äôll then format that line, append it to the result, and reset my buffer for the next line.

> At the end, I‚Äôll format the **last line** separately with left-justification.

---

### 4Ô∏è‚É£ Explain and Implement Optimal Code (Python)

üó£Ô∏è
Let me walk you through my implementation and explain while I write it:

```python
from typing import List

class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res = []              # Final result lines
        line = []             # Buffer for words in the current line
        num_of_letters = 0    # Sum of all characters (excluding spaces)

        for word in words:
            # If adding this word plus the minimum required spaces exceeds maxWidth,
            # we justify the current line and reset.
            if num_of_letters + len(word) + len(line) > maxWidth:
                spaces = maxWidth - num_of_letters

                if len(line) == 1:
                    # If only one word, left-align it and pad right
                    res.append(line[0] + ' ' * spaces)
                else:
                    # Calculate space distribution
                    space_between = spaces // (len(line) - 1)
                    extra = spaces % (len(line) - 1)

                    for i in range(extra):
                        line[i] += ' '  # Distribute extra spaces to the left

                    # Join words with the evenly distributed space
                    res.append((' ' * space_between).join(line))

                # Reset line for the next group
                line = []
                num_of_letters = 0

            # Add current word to the line
            line.append(word)
            num_of_letters += len(word)

        # Handle the last line ‚Äî left-justified
        last_line = ' '.join(line)
        res.append(last_line + ' ' * (maxWidth - len(last_line)))

        return res
```

üó£Ô∏è

> So in this implementation:
>
> * We build up each line word by word
> * When we can‚Äôt fit a word, we justify and flush the line
> * We calculate how many spaces are needed and how to split them
> * The last line is left-justified with `.join()` and padding at the end

---

### 5Ô∏è‚É£ Discuss Time and Space Complexity

üó£Ô∏è
Let‚Äôs talk about complexity:

* **Time complexity** is **O(n)** where `n` is the total number of characters across all words
  ‚Üí We visit each word once, and do basic processing per word or per line

* **Space complexity** is also **O(n)** for storing the final list of justified lines

We don‚Äôt use any additional data structures beyond the output array and some temporary variables.

---

### 6Ô∏è‚É£ Mention Follow-up Questions

üó£Ô∏è
Some potential follow-up questions that might be asked include:

* **What if we needed to support right-alignment only?**
* **How would this change if we were doing center-alignment?**
* **How would you handle localization (e.g., Chinese/Japanese words without spaces)?**
* **Could we stream this line by line in constant memory instead of returning a list?**

---

üß†

> That‚Äôs how I would approach and solve the text justification problem.
> Let me know if you‚Äôd like me to extend this for different alignments or edge cases.


